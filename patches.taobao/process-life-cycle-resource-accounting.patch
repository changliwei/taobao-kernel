From: Coly Li <bosong.ly@taobao.com>
Date: Fri Jan 20 17:51:40 CST 2012
Subject: [PATCH] Process lifecycle resource accounting
Patch-mainline: in house patch
Reference:

This patch is an effort to account many resource consumed
during process lifecycle. The accounting info will simply
be logged into kmsg by printk(). User space tool may
analyze the kmsg log to find more helpful information.

Signed-off-by: Coly Li <bosong.ly@taobao.com>
---
Index: linux-2.6.32-220.2.1.el5/kernel/exit.c
===================================================================
--- linux-2.6.32-220.2.1.el5.orig/kernel/exit.c	2012-01-20 16:12:14.592646865 +0800
+++ linux-2.6.32-220.2.1.el5/kernel/exit.c	2012-01-20 16:12:42.064783102 +0800
@@ -967,6 +967,8 @@
 			setmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);
 	}
 	acct_collect(code, group_dead);
+	lifecycle_resource_acct(tsk);
+
 	if (group_dead)
 		tty_audit_exit();
 	if (unlikely(tsk->audit_context))
Index: linux-2.6.32-220.2.1.el5/kernel/acct.c
===================================================================
--- linux-2.6.32-220.2.1.el5.orig/kernel/acct.c	2012-01-20 16:12:14.584646856 +0800
+++ linux-2.6.32-220.2.1.el5/kernel/acct.c	2012-01-20 17:26:39.326786281 +0800
@@ -59,6 +59,7 @@
 #include <asm/div64.h>
 #include <linux/blkdev.h> /* sector_div */
 #include <linux/pid_namespace.h>
+#include <linux/sched.h>
 
 /*
  * These constants control the amount of freespace that suspend and
@@ -71,6 +72,7 @@
 #define RESUME		(acct_parm[0])	/* >foo% free space - resume */
 #define SUSPEND		(acct_parm[1])	/* <foo% free space - suspend */
 #define ACCT_TIMEOUT	(acct_parm[2])	/* foo second timeout between checks */
+int enable_lifecycle_resource_acct = 0;
 
 /*
  * External references and all of the globals.
@@ -682,3 +684,165 @@
 	for (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent)
 		acct_process_in_ns(ns);
 }
+
+static void __str2hashbuf(const char *msg, int len, __u32 *buf, int num)
+{
+	__u32   pad, val;
+	int	i;
+
+	pad = (__u32)len | ((__u32)len << 8);
+	pad |= pad << 16;
+
+	val = pad;
+	if (len > num*4)
+		len = num * 4;
+	for (i = 0; i < len; i++) {
+		if ((i % 4) == 0)
+			val = pad;
+		val = msg[i] + (val << 8);
+		if ((i % 4) == 3) {
+			*buf++ = val;
+			val = pad;
+			num--;
+		}
+	}
+	if (--num >= 0)
+		*buf++ = val;
+	while (--num >= 0)
+		*buf++ = pad;
+}
+
+/* adapted from Ext3 code */
+#define DELTA 0x9E3779B9
+static void __TEA_transform(__u32 buf[4], __u32 const in[])
+{
+	__u32 sum = 0;
+	__u32 b0 = buf[0], b1 = buf[1];
+	__u32 a = in[0], b = in[1], c = in[2], d = in[3];
+	int n = 16;
+
+	do {
+		sum += DELTA;
+		b0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);
+		b1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);
+	} while (--n);
+
+	buf[0] += b0;
+	buf[1] += b1;
+}
+
+static void get_lifecycle_hash_key(struct task_struct *tsk,
+				   life_racct_t *acct)
+{
+	__u32 in[8], buf[4];
+	unsigned long len;
+	char *cmdline, *p;
+	struct mm_struct *mm = get_task_mm(tsk);
+
+	if (!mm)
+		goto out;
+	if (!mm->arg_end)
+		goto out_mm;
+
+	len = mm->arg_end - mm->arg_start;
+	if (len > PAGE_SIZE)
+		len = PAGE_SIZE;
+
+	cmdline = (char *)kmalloc(len, GFP_NOFS);
+	if (!cmdline) {
+		printk("%s:%d allocate memory for cmdline failed.\n",
+			__func__, __LINE__);
+		goto out_mm;
+	}
+
+	/* copy into kernel space buffer before hashing */
+	if (copy_from_user(cmdline,
+			    (const char __user *)mm->arg_start,
+			    len)) {
+		printk("%s:%d copy cmdlien from user space failed.\n",
+			__func__, __LINE__);
+		goto out_kfree;
+	}
+		
+	buf[0] = 0x67452301;
+	buf[1] = 0xefcdab89;
+	buf[2] = 0x98badcfe;
+	buf[3] = 0x10325476;
+
+	p = cmdline;
+	while(len > 0) {
+		__str2hashbuf(p, len, in, 4);
+		__TEA_transform(buf, in);
+		len -= 16;
+		p += 16;
+	}
+	acct->hash_key[0] = buf[0];
+	acct->hash_key[1] = buf[1];
+
+out_kfree:
+	kfree(cmdline);
+out_mm:
+	mmput(mm);
+out:
+	return;
+}
+
+static void get_lifecycle_cpu_time(struct task_struct *tsk,
+				   life_racct_t *acct)
+{
+	acct->sys_time = task_stime(tsk);
+	acct->usr_time = task_utime(tsk);
+//	acct->real_time = task_rtime(tsk);
+}
+
+static void get_lifecycle_mem_usage(struct task_struct *tsk,
+				    life_racct_t *acct)
+{
+	struct mm_struct *mm = get_task_mm(tsk);
+	if (mm) {
+		unsigned long hiwater_vm, hiwater_rss;
+		hiwater_vm = mm->total_vm;
+		hiwater_rss = get_mm_rss(mm);
+		if (hiwater_vm < mm->hiwater_vm)
+			hiwater_vm = mm->hiwater_vm;
+		if (hiwater_rss < mm->hiwater_rss)
+			hiwater_rss = mm->hiwater_rss;
+		/* vm_peak and vm_rss_peak counted in KB */
+		acct->vm_peak = hiwater_vm << (PAGE_SHIFT - 10);
+		acct->rss_peak = hiwater_rss << (PAGE_SHIFT - 10);
+		mmput(mm);
+	} else {
+		acct->vm_peak = 0;
+		acct->rss_peak = 0;
+	}
+}
+
+static void get_lifecycle_disk_rw(struct task_struct *t,
+				  life_racct_t *acct)
+{
+	struct task_io_accounting ioac = t->ioac;
+
+	acct->read_bytes = (unsigned long)ioac.read_bytes << (PAGE_SHIFT - 10);
+	acct->dirty_bytes = (unsigned long)ioac.write_bytes << (PAGE_SHIFT - 10);
+}
+
+void lifecycle_resource_acct(struct task_struct *t)
+{
+	life_racct_t acct;
+
+	if (!enable_lifecycle_resource_acct)
+		goto out;
+
+	get_lifecycle_hash_key(t, &acct);
+	get_lifecycle_cpu_time(t, &acct);
+	get_lifecycle_mem_usage(t, &acct);
+	get_lifecycle_disk_rw(t, &acct);
+//	get_lifecycle_net_tx_rx(t, &acct);
+
+	/* simply print on dmesg */
+	printk("lifecycle resource consude: hashkey: %x:%x\n",
+		acct.hash_key[0], acct.hash_key[1]);
+out:
+	return;
+}
+
Index: linux-2.6.32-220.2.1.el5/include/linux/acct.h
===================================================================
--- linux-2.6.32-220.2.1.el5.orig/include/linux/acct.h	2012-01-20 16:12:14.576646770 +0800
+++ linux-2.6.32-220.2.1.el5/include/linux/acct.h	2012-01-20 16:47:43.535203731 +0800
@@ -16,6 +16,7 @@
 #define _LINUX_ACCT_H
 
 #include <linux/types.h>
+#include <linux/sched.h>
 
 #include <asm/param.h>
 #include <asm/byteorder.h>
@@ -98,6 +99,42 @@
 };
 
 /*
+ * account resource consumed in process' lifecycle,
+ * including:
+ * - hash key generated by process cmd line parameters
+ * - real on-wall-clock time
+ * - system time
+ * - user space time
+ * - peak vmsize
+ * - peak RSS size
+ * - total pread() bytes
+ * - total dirted bytes by pwrite()
+ * - total bytes send to network
+ * - total bytes read from network
+ 
+ * If lifecycle_resource_acct is enabled, the above
+ * information will be calculated and log to kmsg by
+ * printk(). User space tool can do more analysis
+ * based on the logged information.
+ */
+typedef struct lifecycle_resource_acct {
+	__u32 hash_key[2];
+	cputime_t sys_time;
+	cputime_t usr_time;
+	cputime_t real_time;
+	unsigned long vm_peak;
+	unsigned long rss_peak;
+	unsigned long read_bytes;
+	/*
+	 * if a page only dirted once, dirty_bytes
+	 * can be regarded as write_bytes
+	 */
+	unsigned long dirty_bytes;
+	unsigned long tx_bytes;
+	unsigned long rx_bytes; 
+} life_racct_t;
+
+/*
  *  accounting flags
  */
 				/* bit set when the process ... */
@@ -127,6 +164,7 @@
 extern void acct_collect(long exitcode, int group_dead);
 extern void acct_process(void);
 extern void acct_exit_ns(struct pid_namespace *);
+extern void lifecycle_resource_acct(struct task_struct *t);
 #else
 #define acct_auto_close_mnt(x)	do { } while (0)
 #define acct_auto_close(x)	do { } while (0)
@@ -134,6 +172,7 @@
 #define acct_collect(x,y)	do { } while (0)
 #define acct_process()		do { } while (0)
 #define acct_exit_ns(ns)	do { } while (0)
+#define lifecycle_resource_acct() do { } while (0)
 #endif
 
 /*
Index: linux-2.6.32-220.2.1.el5/kernel/sysctl.c
===================================================================
--- linux-2.6.32-220.2.1.el5.orig/kernel/sysctl.c	2012-01-20 16:12:41.368779644 +0800
+++ linux-2.6.32-220.2.1.el5/kernel/sysctl.c	2012-01-20 16:16:16.525846559 +0800
@@ -180,6 +180,7 @@
 
 #ifdef CONFIG_BSD_PROCESS_ACCT
 extern int acct_parm[];
+extern int enable_lifecycle_resource_acct;
 #endif
 
 #ifdef CONFIG_IA64
@@ -692,6 +693,15 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+
+	{
+		.ctl_name	= KERN_LIFECYCLE_RESOURCE_ACCT,
+		.procname	= "enable_lifecycle_resource_acct",
+		.data		= &enable_lifecycle_resource_acct,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
 #endif
 #ifdef CONFIG_MAGIC_SYSRQ
 	{
Index: linux-2.6.32-220.2.1.el5/include/linux/sysctl.h
===================================================================
--- linux-2.6.32-220.2.1.el5.orig/include/linux/sysctl.h	2012-01-20 16:12:41.368779644 +0800
+++ linux-2.6.32-220.2.1.el5/include/linux/sysctl.h	2012-01-20 16:16:51.914021961 +0800
@@ -162,6 +162,7 @@
 	KERN_MAX_LOCK_DEPTH=74,
 	KERN_NMI_WATCHDOG=75, /* int: enable/disable nmi watchdog */
 	KERN_PANIC_ON_NMI=76, /* int: whether we will panic on an unrecovered */
+	KERN_LIFECYCLE_RESOURCE_ACCT=77, /* int: whether account resource on process exit */
 };
 
 
